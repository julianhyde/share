---
layout: post
title: Auto-generated date dimension tables
date: '2012-02-21T21:04:00.000-08:00'
author: Julian Hyde
tags: 
modified_time: '2012-02-21T21:04:06.203-08:00'
blogger_id: tag:blogger.com,1999:blog-5672165237896126100.post-5896065140480667021
blogger_orig_url: https://julianhyde.blogspot.com/2012/02/auto-generated-date-dimension-tables.html
---

It seems that whenever I have a cross-continent flight, Mondrian gets a new feature. This particular flight was from Florida back home to California, and this particular feature is a time-dimension generator.<br /><br />I was on the way home from an all-hands at Pentaho's Orlando, Florida headquarters, where <a href="http://www.pentaho.com/press-room/releases/pentaho-appoints-quentin-gallivan-as-ceo/" target="_blank">new CEO Quentin Gallivan</a> had outlined his strategy for the company. I also got to spend time with the many smart folks from all over the world who work for Pentaho, among them <a href="http://rpbouman.blogspot.com/" target="_blank">Roland Bouman</a>, formerly an evangelist for MySQL, now with Pentaho, but still passionately advocating for open source databases, open source business intelligence, and above all, keeping it simple.<br /><br />Roland and I got talking about how to map Mondrian onto operational schemas. Though not designed as star schemas, some operational schemas nevertheless have a structure that can support a cube, with a central fact table surrounded by star or snowflake dimension tables. Often the one thing missing is a time dimension table. Since these time dimension tables look very much the same, how easy would it be for Mondrian to generate them on the fly? Not that difficult, I thought, as the captain turned off the "fasten seatbelts" sign and I opened my laptop. Here's what I came up with.<br /><br />Here's how you declare a regular time dimension table in Mondrian 4:<br /><br /><code>&lt;PhysicalSchema&gt;<br />&nbsp;&nbsp;&lt;Table name='time_by_day'/&gt;<br />&nbsp;&nbsp;&lt;!-- Other tables... --&gt;<br />&lt;/PhysicalSchema&gt;</code><br /><br />Mondrian sees the table name 'time_by_day', checks that it exists, and finds the column definitions from the JDBC catalog. The table can then be used in various dimensions in the schema.<br /><br />An auto-generated time dimension is similar:<br /><br /><code>&lt;PhysicalSchema&gt;<br />&nbsp;&nbsp;&lt;AutoGeneratedDateTable name='time_by_day_generated' startDate='2012-01-01' endDate='2014-01-31'/&gt;<br />&nbsp;&nbsp;&lt;!-- Other tables... --&gt;<br />&lt;/PhysicalSchema&gt;</code> <br /><br />The first time Mondrian reads the schema, it notices that the table is not present in the schema, and creates and populates it. Here is the DDL and data it produces.<br /><br /><code>CREATE TABLE `time_by_day_generated` (<br />&nbsp;&nbsp;`time_id` Integer NOT NULL PRIMARY KEY,<br />&nbsp;&nbsp;`yymmdd` Integer NOT NULL,<br />&nbsp;&nbsp;`yyyymmdd` Integer NOT NULL,<br />&nbsp;&nbsp;`the_date` Date NOT NULL,<br />&nbsp;&nbsp;`the_day` VARCHAR(20) NOT NULL,<br />&nbsp;&nbsp;`the_month` VARCHAR(20) NOT NULL,<br />&nbsp;&nbsp;`the_year` Integer NOT NULL,<br />&nbsp;&nbsp;`day_of_month` VARCHAR(20) NOT NULL,<br />&nbsp;&nbsp;`week_of_year` Integer NOT NULL,<br />&nbsp;&nbsp;`month_of_year` Integer NOT NULL,<br />&nbsp;&nbsp;`quarter` VARCHAR(20) NOT NULL)</code><br /><table border="1"><tbody><tr><th>JULIAN</th><th>YYMMDD</th><th>YYYYMMDD</th><th>DATE</th><th>DAY_OF_WEEK_NAME</th><th>MONTH_NAME</th><th>YEAR</th><th>DAY_OF_MONTH</th><th>WEEK_OF_YEAR</th><th>MONTH</th><th>QUARTER</th></tr><tr><td>2455928</td><td>120101</td><td>20120101</td><td>2012-01-01</td><td>Sunday</td><td>January</td><td>2012</td><td>1</td><td>1</td><td>1</td><td>Q1</td></tr><tr><td>2455929</td><td>120102</td><td>20120102</td><td>2012-01-02</td><td>Monday</td><td>January</td><td>2012</td><td>2</td><td>1</td><td>1</td><td>Q1</td></tr><tr><td>2455930</td><td>120103</td><td>20120103</td><td>2012-01-03</td><td>Tuesday</td><td>January</td><td>2012</td><td>3</td><td>1</td><td>1</td><td>Q1</td></tr></tbody></table><br />The columns present are all of the time-dimension domains:<br /><br /><table border="1"><tbody><tr><th>Domain</th><th>Default column name</th><th>Default data type</th><th>Example</th><th>Description</th></tr><tr><td>JULIAN        </td><td>time_id    </td><td>Integer          </td><td>2454115</td><td>Julian day number (0 = January 1, 4713 BC). Additional attribute 'epoch', if specified, changes the date at which the value is zero.</td></tr><tr><td>YYMMDD        </td><td>yymmdd     </td><td>Integer          </td><td>120219</td><td>Decimal date with two-digit year</td></tr><tr><td>YYYYMMDD      </td><td>yyyymmdd   </td><td>Integer          </td><td>20120219</td><td>Decimal date with four-digit year</td></tr><tr><td>DATE          </td><td>the_date   </td><td>Date             </td><td>2012-12-31</td><td>Date literal</td></tr><tr><td>DAY_OF_WEEK_NAME</td><td>the_day  </td><td>String           </td><td>Friday</td><td>Name of day of week</td></tr><tr><td>MONTH_NAME    </td><td>the_month  </td><td>String           </td><td>December</td><td>Name of month</td></tr><tr><td>YEAR          </td><td>the_year   </td><td>Integer          </td><td>2012</td><td>Year</td></tr><tr><td>DAY_OF_MONTH  </td><td>day_of_month</td><td>String          </td><td>31</td><td>Day ordinal within month</td></tr><tr><td>WEEK_OF_YEAR  </td><td>week_of_year</td><td>Integer         </td><td>53</td><td>Week ordinal within year</td></tr><tr><td>MONTH         </td><td>month_of_year</td><td>Integer        </td><td>12</td><td>Month ordinal within year</td></tr><tr><td>QUARTER       </td><td>quarter     </td><td>String          </td><td>Q4</td><td>Name of quarter</td></tr></tbody></table><br />Suppose you wish to choose specific column names, or have more control over how values are generated. You can do that by including a <code>&lt;ColumnDefs&gt;</code> element within the table, and <code>&lt;ColumnDef&gt;</code>elements within that â€” just like a regular <code>&lt;Table&gt;</code>element.<br /><br />For example,<br /><br /><code>&lt;PhysicalSchema&gt;<br />&nbsp;&nbsp;&lt;AutoGeneratedDateTable name='time_by_day_generated' startDate='2008-01-01 endDate='2020-01-31'&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&lt;ColumnDefs&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ColumnDef name='time_id'&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;TimeDomain role='JULIAN' epoch='1996-01-01'/&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/ColumnDef&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ColumnDef name='my_year'&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;TimeDomain role='year'/&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/ColumnDef&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ColumnDef name='my_month'&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;TimeDomain role='MONTH'/&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/ColumnDef&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ColumnDef name='quarter'/&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ColumnDef name='month_of_year'/&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ColumnDef name='week_of_year'/&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ColumnDef name='day_of_month'/&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ColumnDef name='the_month'/&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ColumnDef name='the_date'/&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&lt;/ColumnDefs&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&lt;Key&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Column name='time_id/&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Key&gt;<br />&nbsp;&nbsp;&lt;/AutoGeneratedDateTable&gt;<br />&nbsp;&nbsp;&lt;!-- Other tables... --&gt;<br />&lt;/PhysicalSchema&gt;</code><br /><br />The first three columns have nested <code>&lt;TimeDomain&gt;</code>elements that tell the generator how to populate them.<br /><br />The other columns have the standard column name for a particular time domain, and therefore the <code>&lt;TimeDomain&gt;</code> element can be omitted. For instance,<br /><br /><code>&lt;ColumnDef name='month_of_year'/&gt;</code><br /><br />is shorthand for<br /><br /><code>&lt;ColumnDef name='month_of_year' type='int'&gt;<br />&nbsp;&nbsp;&lt;TimeDomain role="month"/&gt;<br />&lt;/ColumnDef&gt;</code><br /><br />The nested <code>&lt;Key&gt;</code> element makes that column valid as the target of a link (from a foreign key in the fact table, for instance), and also declares the column as a primary key in the CREATE TABLE statement. This has the pleasant side-effect, on all databases I know of, of creating an index. If you need other indexes on the generated table, create them manually.<br /><br />The <code>&lt;TimeDomain&gt;</code> element could be extended further. For instance, we could add a locale attribute. This would allow different translations of month and weekday names, and also support locale-specific differences in how week-in-day and day-of-week numbers are calculated.<br /><br />Note that this functionality is checked into the mondrian-lagunitas branch, so will only be available as part of Mondrian version 4. That release is still pre-alpha. We recently started to regularly build the branch using <a href="http://ci.pentaho.com/view/Analysis/job/mondrian-4/" target="_blank">Jenkins</a>, and you should see the number of failing tests dropping steadily over the next weeks and months. Already over 80% of tests pass, so it's worth downloading the latest build to kick the tires on your application.