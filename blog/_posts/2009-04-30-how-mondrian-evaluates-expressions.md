---
layout: post
title: How Mondrian evaluates expressions
date: '2009-04-30T10:43:00.000-07:00'
author: Julian Hyde
tags:
- mondrian cache calculated members
modified_time: '2009-04-30T11:22:19.772-07:00'
blogger_id: tag:blogger.com,1999:blog-5672165237896126100.post-2590586374515504298
blogger_orig_url: https://julianhyde.blogspot.com/2009/04/how-mondrian-evaluates-expressions.html
---

When it comes to expression evaluation, Mondrian keeps things simple. It doesn't tend to cache the results of expressions, but calculates them each time they are evaluated. Eventually the calculation tunnels through all calculated members and ends up at an atomic cell. Atomic cells are retrieved from the database, and stored in the cell value cache, so they are only calculated once.<br /><br />By the way, an atomic cell is not necessarily at the lowest level of the hierarchy; Mondrian would prefer to load cells at a coarse granularity, and leave the hard work of aggregating values to the database, or even better, an aggregate table. And Mondrian does its best to retrieve atomic cells in batches. It gathers together requests for lots of cells of the same granularity and generates a single SQL statement to retrieve them all at once.<br /><br />Mondrian's 'keep it simple' scheme comes unstuck when a particular calculation is repeated many times over. Nick Goodman came up with a classic example of this in <a href="http://jira.pentaho.org:8080/browse/MONDRIAN-552">bug MONDRIAN-552</a>. The query is as follows:<br /><blockquote><pre>with member [Measures].[Profit Change] as<br />   ([Measures].[Profit], [Time].CurrentMember)<br />   - ([Measures].[Profit], [Time].PrevMember)<br />member [Measures].[Running Total] as<br />   ([Measures].[Profit], [Time].CurrentMember)<br />   + ([Measures].[Running Total], [Time].PrevMember)<br />member [Measures].[Average Daily Running Total] as<br />   Avg(<br />       Descendants(<br />           [Time].CurrentMember, [Time.Weekly].[Day])<br />      [Measures].[Running Total])<br />select<br />   {[Measures].[Profit Change],<br />     [Measures].[Running Total],<br />     [Measures].[Average Daily Running Total]} ON COLUMNS,<br />   {[Time.Weekly].[Week].Members} ON ROWS<br />from [Sales]</pre></blockquote>Note how [Measures].[Running Total] is recursive. The running total for week 3 is defined as the running total for week 2 plus the profit for week 3. To calculate the average running total for week 99, Mondrian computes profit for the first 99 weeks and to calculate the average running total for week 100, Mondrian computes profit 100 for the first 100 weeks. There's lots of wasted effort: Mondrian has computed profit 50,000 times when it could have done it just 100 times and cached the results.<br /><br />The solution is simple: wrap the calculation for [Measures].[Running Total] in the <a href="http://mondrian.pentaho.org/documentation/performance.php#Optimizing_Calculations_with_the_Expression_Cache">Cache() function</a>, and Mondrian will compute the value only once.<br /><br />You will see that in the bug I come up with a couple of proposals for making Mondrian better. I don't think Mondrian should automatically cache every expression, because caching costs time and memory, and most expressions are only evaluated once or twice. And by the way, you should use the Cache function sparingly, for the same reason.<br /><br />But it would be nice if Mondrian could automatically detect some cases where expression caching is desirable. The proposed 'cache' property of a calculated member would have three values: 0 (never cache), 1 (always cache) and null (Mondrian should use its best judgment). Most calculated members would leave the caching up to Mondrian, so we would need to come up with a simple, effective rule that governs caching before we implemented this feature. What do you think the rule should be?