---
layout: post
title: Roll your own high-performance Java collections classes
date: '2011-06-03T12:58:00.000-07:00'
author: Julian Hyde
tags:
- efficient primitive java collections janino
modified_time: '2011-06-04T00:07:02.438-07:00'
blogger_id: tag:blogger.com,1999:blog-5672165237896126100.post-8339921548425500424
blogger_orig_url: https://julianhyde.blogspot.com/2011/06/roll-your-own-high-performance-java.html
---

The Java collections framework is great. You can create maps, sets, lists with various element types, various performance characteristics (e.g. if you want O(1) insert, use a linked list), iterate over them, and you can decorate them to give them other behaviors.<br /><br />But suppose that you want to create a high-performance, memory efficient immutable list of integers? You'd write<br /><br /><code>List&lt;Integer&gt; list =<br />&nbsp;&nbsp;Collections.unmodifiableList(<br />&nbsp;&nbsp;&nbsp;&nbsp;new ArrayList<integer>(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Arrays.asList(1000, 1001, 1002)));</code><br /><br />There will be 6 objects allocated in the JVM: three Integer objects, an array Object[3] to hold the Integers, an ArrayList, and an UnmodifiableRandomAccessList. Not to mention the Arrays.ArrayList and Integer[3] used to construct the list and quickly thrown away.<br /><br />The resulting list is no longer high-performance. A call to say 'int n = list.get(2)' requires 3 method calls (UnmodifiableRandomAccessList.get, ArrayList.get, Integer.intValue) and 3 indirections. And the sheer number of objects created reduces the chance that a given stretch of code will be able to operate solely from the contents of L1 cache.<br /><br />So, what next? Should I write my own class, like this?<br /><br /><code>public class UnmodifiableNativeIntArrayList<br />&nbsp;&nbsp;implements List&lt;Integer&gt;<br />{<br />&nbsp;&nbsp;...<br />}</code><br /><br />Well, maybe. But there are rather a lot of variations to cover, and each one needs to be hand-coded and tested.<br /><br />Do I use library code? I searched and turned up <a href="http://commons.apache.org/primitives/">Apache Commons Primitives</a>, <a href="http://pcj.sourceforge.net/">Primitive Collections for Java (PCJ)</a>, and <a href="http://trove.starlight-systems.com/">GNU Trove (trove4j)</a>. Of these, only GNU Trove is still active.<br /><br />None of the libraries supports features such as maps with two or more keys, unmodifiable collections, synchronized collections, flat collections (similar to <a href="http://commons.apache.org/collections/api-3.2/org/apache/commons/collections/map/Flat3Map.html">Apache Flat3Map</a>). It's not surprising that they don't: each combination of features would require its own class, so the size of the jar file would grow exponentially.<br /><br />So, I'd like to propose an alternate approach. You configure a factory, specifying the precise kind of collection you would like, and the factory generates the collection class in bytecode. You can use the factory to quickly create as many instances of the collection as you wish. The collection implements the Java collections interfaces, plus additional interfaces that allow you to efficiently access the collection without boxing/unboxing.<br /><br />The above example would be written as follows:<br /><br /><code>// Initialize the factory when the program is loaded.<br />// Then the bytecode gets generated just once.<br />static final Factory factory =<br />&nbsp;&nbsp;new FactoryBuilder()<br />&nbsp;&nbsp;&nbsp;&nbsp;.list()<br />&nbsp;&nbsp;&nbsp;&nbsp;.elementType(Integer.TYPE)<br />&nbsp;&nbsp;&nbsp;&nbsp;.modifiable(false)<br />&nbsp;&nbsp;&nbsp;&nbsp;.factory();<br /><br />int[] ints = {1000, 1001, 1002};<br />IntList list = factory.createIntList(ints);</code><br /><br />Variants are expressed as FactoryBuilder methods:<br /><ul><li>FactoryBuilder FactoryBuilder.list()</li><li>FactoryBuilder FactoryBuilder.map()</li><li>FactoryBuilder FactoryBuilder.set()</li><li>FactoryBuilder FactoryBuilder.keyType(Class...) (for maps only)</li><li>FactoryBuilder FactoryBuilder.valueType(Class...) (for maps only)</li><li>FactoryBuilder FactoryBuilder.elementType(Class...) (for list and set only)</li><li>FactoryBuilder FactoryBuilder.sorted(boolean) (cf. the difference between Set and SortedSet)</li><li>FactoryBuilder FactoryBuilder.deterministic(boolean) (cf. the difference between HashMap and LinkedHashMap)</li><li>FactoryBuilder FactoryBuilder.modifiable(boolean)</li><li>FactoryBuilder FactoryBuilder.fixedSize(boolean) (cf. the difference between Flat3Map and Map)</li><li>FactoryBuilder FactoryBuilder.synchronized(boolean)</li></ul><br />And so forth. Additional variants could be added as the project evolved. Templates could be fine-tuned for particular combinations of variants.<br /><br />The projects I mentioned above clearly use a template system, and we could use and extend those templates. The janino facility can easily convert the generated java code into bytecode. And the JVM would be able to apply JIT (just-in-time compilation) to these classes; in fact, these classes would be more amenable to compilation, because they would be compact and final.<br /><br />The existing projects have invested a lot of effort designing high-performance collections. I'd like to build on that work; this project could even be an extension to those projects.<br /><br />I'd like to hear if you're interested in working with me on this.