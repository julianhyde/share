---
layout: post
title: Cell writeback in Mondrian
date: '2009-06-11T18:18:00.000-07:00'
author: Julian Hyde
tags:
- mondrian mdx writeback
modified_time: '2009-06-22T10:18:41.110-07:00'
blogger_id: tag:blogger.com,1999:blog-5672165237896126100.post-2859338247682311979
blogger_orig_url: https://julianhyde.blogspot.com/2009/06/cell-writeback-in-mondrian.html
---

<div>Writeback is a feature that allows you to modify OLAP cell values and see the effects ripple through the data set, automatically modifying child and parent cells, and also cells derived using calculations. This allows you to perform 'what if' analysis and applications such as budgeting.</div><div><br /></div><div>I have added experimental support for writeback to Mondrian.</div><div><br /></div><div>In Mondrian's case, the term 'writeback' is a bit misleading. In a ROLAP system such as Mondrian, writing back to the database would be difficult, since values are stored in a fact table but we allow cells of any granularity to be modified. One modified cell might contain thousands of fact table rows. So, we don't write cells back to the database, but just retain the modified cells in memory, and propagate the modifications to related cells.</div><div><br /></div><div>Here's how to use the experimental writeback support. Some of the details may change later as we make the feature more usable.</div><div><br /></div><div>First, enable writeback for your cube. Create a dimension called 'Scenario', and a measure called 'Atomic Cell Count':</div><blockquote><pre><div>&lt;Cube name='Sales'&gt;</div><div>    &lt;Dimension name='Scenario' foreignKey='time_id'&gt;</div><div>        &lt;Hierarchy primaryKey='time_id' hasall='true'&gt;</div><div>            &lt;InlineTable alias='_dummy'&gt;</div><div>                &lt;ColumnDefs&gt;</div><div>                    &lt;ColumnDef name='foo' type='Numeric'/&gt;</div><div>                &lt;/ColumnDefs&gt;</div><div>                &lt;Rows/&gt;</div><div>            &lt;/InlineTable&gt;</div><div>            &lt;Level name='Scenario' column='foo'/&gt;</div><div>        &lt;/Hierarchy&gt;</div><div>    &lt;/Dimension&gt;</div><div>    &lt;!-- Other dimensions... --&gt;</div><div>   &lt;Measure name='Atomic' aggregator='count'/&gt;</div><div>    &lt;!-- Other measures... --&gt;</div><div>&lt;/Cube&gt;</div></pre></blockquote><div>(Yes, this is a lot of crud to add to your cube definition, and it's temporary. In future, we will let you flag a cube as 'writeback enabled', and a [Scenario] dimension and [Atomic Cell Count] measure will be created automatically. Also, we will make it easier for you to create dimensions that have only calculated members, without resorting to inline tables.)</div><div><br /></div><div>Next, create a Scenario:</div><blockquote><pre><div>Connection connection;</div><div>Scenario scenario = connection.createScenario();</div><div>int scenarioId = scenario.getId();</div></pre></blockquote><div>(The Scenario API will soon move to <a href="http://www.olap4j.org/">olap4j</a>: before mondrian-4.0, I hope. This includes the class <code>mondrian.olap.Scenario</code>, the method <code>mondrian.olap.Cell.setValue()</code>, and the method <code>mondrian.olap.Connection.createScenario()</code>. It will be optional for an olap4j driver to support writeback, but Mondrian's olap4j driver will, of course.)</div><div><br /></div><div>Write a query that uses the scenario. Assuming that <code>scenarioId</code> above was 1, the query</div><blockquote><pre>SELECT [Measures].[Unit Sales] ON COLUMNS,<div>    {[Product],</div><div>     [Product].Children,</div><div>     [Product].[Drink].Children} ON ROWS</div><div>FROM [Sales]</div><div>WHERE [Scenario].[1]</div></pre></blockquote><div>returns</div><blockquote><pre><div>[Product]                 [Unit Sales]</div><div>========================= ============</div><div>(All)                          266,773</div><div> + Drink                        24,597</div><div> +--+ Alcoholic Beverages        6,838</div><div> +--+ Beverages                 13,573</div><div> +--+ Dairy                      4,186</div><div> + Food                        191,940</div><div> + Non-Consumable               50,236</div></pre></blockquote><div>Choose one of the cells returned from the query and modify its value. For example, let's reduce the sales of Drink by 1,000 from 24,597 to 23,597:</div><blockquote><pre><div>Result result = connection.executeQuery(...);</div><div>Cell cell = result.getCell(new int[] {0, 1});</div><div>cell.setValue(23597, AllocationPolicy.EQUAL_ALLOCATION);</div></pre></blockquote><div>Execute the query again, and it returns</div><blockquote><pre><div>[Product]                 [Unit Sales]</div><div>========================= ============</div><div>(All)                          265,773</div><div> + Drink                        23,597</div><div> +--+ Alcoholic Beverages        6,563</div><div> +--+ Beverages                 12,990</div><div> +--+ Dairy                      4,043</div><div> + Food                        191,940</div><div> + Non-Consumable               50,236</div></pre></blockquote><div>The value for Drink is 23,597, as expected, and the values of its children have been correspondingly reduced.</div><div><br /></div><div>How the value is allocated to the children (and in fact all descendants) is decided by the allocation policy. In this case, we specified EQUAL_ALLOCATION, which means that all atomic cells have the same value.</div><div><br /></div><div>An atomic cell is the finest grained value that can be viewed multidimensionally; for this cube, it is an instance of a particular customer buying a particular product, on a particular promotion, on a particular day, in a particular store. That makes for an awful lot of of atomic cells, but there may be fewer atomic cells than fact table rows. If the fact table does not have a primary key on (customer, product, time, promotion, store) some cells may have more than one fact table row. </div><div><br /></div><div>If instead we had written</div><blockquote><pre><div>cell.setValue(23597, AllocationPolicy.EQUAL_INCREMENT);</div></pre></blockquote><div>the query would have returned</div><blockquote><pre><div>[Product]                 [Unit Sales]</div><div>========================= ============</div><div>(All)                          265,773</div><div> + Drink                        23,597</div><div> +--+ Alcoholic Beverages        6,560</div><div> +--+ Beverages                 13,022</div><div> +--+ Dairy                      4,015</div><div> + Food                        191,940</div><div> + Non-Consumable               50,236</div></pre></blockquote><div>We notice that Beverages has not been reduced as much under EQUAL_INCREMENT policy than EQUAL_ALLOCATION policy; the average value for atomic cells of Beverages must be greater than for Drink as a whole.</div><div><br /></div><div>Allocation policies are defined consistent with Analysis Services' <a href="http://technet.microsoft.com/en-us/library/ms145488.aspx">UPDATE CUBE statement</a>. Mondrian does not currently implement WEIGHTED_ALLOCATION or WEIGHTED_INCREMENT policies.</div><div><br /></div><div>Treating scenarios as a dimension is an elegant and powerful idea. Using the Scenario dimension, you can easily switch from one scenario to another, or you can compare scenarios side-by-side.</div><div><br /></div><div>Note that you can also set a connection's current scenario. This effectively becomes the default value for the Scenario dimension in that connection, so you do not need to specify Scenario in the slicer. However, there still needs to be an explicit scenario in the context when you call <code>Cell.setValue()</code>. I'm not sure whether the benefit of having a scenario for a connection outweighs the benefit/confusion, and we may discontinue this feature.</div><div><br /></div><div>Remember, this is still an experimental feature. There is some cleanup to be done, some performance tuning, and the API needs to be moved into olap4j. But most importantly, it's not useful until a user interface, such as PAT or JPivot, supports scenarios and modifying cell values.</div>