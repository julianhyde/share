---
layout: post
title: Mondrian cache control
date: '2007-02-13T18:37:00.000-08:00'
author: Julian Hyde
tags: 
modified_time: '2009-04-18T13:52:34.524-07:00'
blogger_id: tag:blogger.com,1999:blog-5672165237896126100.post-5055608065354412098
blogger_orig_url: https://julianhyde.blogspot.com/2007/02/mondrian-cache-control.html
---

One of the strengths of mondrian's design is that you don't need to do any processing to populate special data structures before you start running OLAP queries. More than a few people have observed that this makes mondrian an excellent choice for 'real-time OLAP' -- running multi-dimensional queries on a database which is constantly changing.<br /><br />The problem is that mondrian's cache gets in the way. Usually the cache is a great help, because it ensures that mondrian only goes to the DBMS once for a given piece of data, but the cache becomes out of date if the underlying database is changing.<br /><br />This is solved with a new set of APIs for cache control in mondrian-2.3. Before I explain the API, let's understand how mondrian caches data.<br /><br /><span style="font-weight: bold;font-size:130%;" >How mondrian's cache works</span><br /><p>Mondrian's cache ensures that once a multidimensional cell -- say the Unit Sales of Beer in Texas in Q1, 1997 -- has been retrieved from the DBMS using an SQL query, it is retained in memory for subsequent MDX calculations. That cell may be used later during the execution of the same MDX query, and by future queries in the same session and in other sessions. The cache is a major factor ensuring that Mondrian is responsive for speed-of-thought analysis.</p>The cache operates at a lower level of abstraction than access control. If the current role is only permitted to see only sales of Dairy products, and the query asks for all sales in 1997, then the request sent to Mondrian's cache will be for Dairy sales in 1997. This ensures that the cache can safely be shared among users which have different permissions.<br /><br />If the contents of the DBMS change while Mondrian is running, Mondrian's implementation must overcome some challenges. The end-user expects a speed-of-thought query response time yielding a more or less up-to-date view of the database. Response time necessitates a cache, but this cache will tend to become out of date as the database is modified.<br /><br />Mondrian cannot deduce when the database is being modified, so we introduce an API so that the container can tell Mondrian which parts of the cache are out of date. Mondrian's implementation must ensure that the changing database state does not yield inconsistent query results.<br /><p>Until now, control of the cache has been very crude: applications would typically call<br /></p><blockquote style="font-family: courier new;">mondrian.rolap.RolapSchema.clearCache();</blockquote>to flush the cache which maps connect string URLs to in-memory datasets. The effect of this call is that a future connection will have to re-load metadata by parsing the schema XML file, and then load the data afresh.<br /><br />There are a few problems with this approach. Flushing all data and metadata is all appropriate if the contents of a schema XML file has changed, but we have thrown out the proverbial baby with the bath-water. If only the data has changed, we would like to use a cheaper operation.<br /><br />The final problem with the <span style="font-family:courier new;">clearCache()</span> method is that it affects only new connections. Existing connections will continue to use the same metadata and stale data, and will compete for scarce memory with new connections.<br /><p><br /><span style="font-weight: bold;font-size:130%;" >New CacheControl API</span><br /><br />The new <span style="font-weight: bold;font-family:courier new;" >CacheControl</span> API solves all of the problems described above. It provides fine-grained control over data in the cache, and the changes take place as soon as possible while retaining a consistent view of the data.<br /></p><p>When a connection uses the API to notify Mondrian that the database has changed, subsequent queries will see the new state of the database. Queries in other connections which are in progress when the notification is received will see the database state either before or after the notification, but in any case, will see a consistent view of the world.<br /></p><p>The cache control API uses the new concept of a <span style="font-weight: bold; font-style: italic;">cache region</span>, an area of multidimensional space defined by one or more members. To flush the cache, you first define a cache region, then tell Mondrian to flush all cell values which relate to that region. To ensure consistency, Mondrian automatically flushes all rollups of those cells.<br /><br /><span style="font-weight: bold;">A simple example</span><br /><br />Suppose that a connection has executed a query:<br /></p><blockquote><pre><span style="font-weight: bold;font-family:courier new;" >import mondrian.olap.*;<br /><br />Connection connection;<br />Query query = connection.parseQuery(<br />"SELECT" +<br />"  {[Time].[1997]," +<br />"    [Time].[1997].Children} ON COLUMNS," +<br />"  {[Customer].[USA]," +<br />"    [Customer].[USA].[OR]," +<br />"    [Customer].[USA].[WA]} ON ROWS" +<br />"FROM [Sales]");<br />Result result = connection.execute(query);</span></pre></blockquote>and that this has populated the cache with the following segments:<br /><blockquote>Segment YN#1<br /><blockquote><span style="font-weight: bold;font-family:courier new;" ><pre>Year Nation Unit Sales<br />1997 USA    xxx<br /><br />Predicates: Year=1997, Nation=USA</pre></span></blockquote>Segment YNS#1<br /><blockquote><span style="font-weight: bold;font-family:courier new;" ><pre>Year Nation State Unit Sales<br />1997 USA    OR    xxx<br />1997 USA    WA    xxx<br /><br />Predicates: Year=1997, Nation=USA, State={OR, WA}</pre></span></blockquote>Segment YQN#1<br /><blockquote><span style="font-weight: bold;font-family:courier new;" ><pre>Year Quarter Nation Unit Sales<br />1997 Q1      USA    xxx<br />1997 Q2      USA    xxx<br /><br />Predicates: Year=1997, Quarter=any, Nation=USA</pre></span></blockquote>Segment YQNS#1<br /><blockquote><span style="font-weight: bold;font-family:courier new;" ><pre>Year Quarter Nation State Unit Sales<br />1997 Q1      USA    OR    xxx<br />1997 Q1      USA    WA    xxx<br />1997 Q2      USA    OR    xxx<br />1997 Q2      USA    WA    xxx<br /><br />Predicates: Year=1997, Quarter=any, Nation=USA, State={OR, WA}</pre></span></blockquote></blockquote>Now suppose that the application knows that batch of rows from Oregon, Q2 have been updated in the fact table. The application notifies Mondrian of the fact by defining a cache region:<br /><blockquote><span style="font-weight: bold;font-family:courier new;" ><pre>// Lookup members<br />Cube salesCube =<br />connection.getSchema().lookupCube(<br />"Sales", true);<br />SchemaReader schemaReader =<br />salesCube.getSchemaReader(null);<br />Member memberTimeQ2 =<br />schemaReader.getMemberByUniqueName(<br />new String[]{"Time", "1997", "Q2"},<br />true);<br />Member memberCustomerOR =<br />schemaReader.getMemberByUniqueName(<br />new String[]{"Customer", "USA", "OR"},<br />true);<br /><br />// Create a cache region defined by<br />// [Time].[1997].[Q2] cross join<br />// [Customer].[USA].[OR].<br />CacheControl.CellRegion measuresRegion =<br />cacheControl.createMeasuresRegion(<br />salesCube);<br />CacheControl.CellRegion regionTimeQ2 =<br />cacheControl.createMemberRegion(<br />memberTimeQ2, true);<br />CacheControl.CellRegion regionCustomerOR =<br />cacheControl.createMemberRegion(<br />memberCustomerOR, true);<br />CacheControl.CellRegion regionOregonQ2 =<br />cacheControl.createCrossjoinRegion(<br />measuresRegion,<br />regionCustomerOR,<br />regionTimeQ2);</pre></span></blockquote>and flushing that region:<br /><blockquote><span style="font-weight: bold;font-family:courier new;" >cacheControl.flush(regionOregonQ2);</span></blockquote>Now let's look at what segments are left in memory after the flush.<br /><blockquote>Segment YNS#1<br /><blockquote><span style="font-weight: bold;font-family:courier new;" ><pre>Year Nation State Unit Sales<br />1997 USA    OR    xxx<br />1997 USA    WA    xxx<br /><br />Predicates: Year=1997, Nation=USA, State={WA}</pre></span></blockquote>Segment YQN#1<br /><blockquote><span style="font-weight: bold;font-family:courier new;" ><pre>Year Quarter Nation Unit Sales<br />1997 Q1      USA    xxx<br />1997 Q2      USA    xxx<br /><br />Predicates: Year=1997, Quarter={any except Q2}, Nation=USA</pre></span></blockquote>Segment YQNS#1<br /><blockquote><span style="font-weight: bold;font-family:courier new;" ><pre>Year Quarter Nation State Unit Sales<br />1997 Q1      USA    OR    xxx<br />1997 Q1      USA    WA    xxx<br />1997 Q2      USA    OR    xxx<br />1997 Q2      USA    WA    xxx<br /><br />Predicates: Year=1997, Quarter=any, Nation=USA, State={WA}</pre></span></blockquote></blockquote>The effects are:<br /><ul><li>Segment YN#1 has been deleted. All cells in the segment could contain values in Oregon/1997/Q2.</li></ul><ul><li>The constraints in YNS#1 have been strengthened. The constraint on the State column is modified from State={OR, WA} to State={WA} so that future requests for (1997, Q2, USA, OR) will not consider this segment.</li></ul><ul><li>The constraints in YQN#1 have been strengthened. The constraint on the Quarter column is modified from Quarter=any to Quarter={any except Q2}.</li></ul><ul><li>The constraints in YQNS#1 have been strengthened, similar to YNS#1.</li></ul><span style="font-weight: bold;font-size:130%;" >More about cell regions</span><br /><br />The previous example showed how to make a cell region consisting of a single member, and how to combine these regions into a two-dimensional region using a crossjoin. The CacheControl API supports several methods of creating regions:<br /><ul><li><span style="font-weight: bold;font-family:courier new;" >createMemberRegion(Member, boolean)</span> creates a region containing a single member, optionally including its descendants.</li><li><span style="font-weight: bold;font-family:courier new;" >createMemberRegion(boolean lowerInclusive, Member lowerMember, boolean upperInclusive, Member upperMember, boolean descendants)</span> creates a region containing a range of members, optionally including their descendants, and optionally including each endpoint. A range may be either closed, or open at one end.</li><li><span style="font-weight: bold;font-family:courier new;" >createCrossjoinRegion(CellRegion...)</span> combines several regions into a higher dimensionality region. The constituent regions must not have any dimensions in common.</li><li><span style="font-weight: bold;font-family:courier new;" >createUnionRegion(CellRegion...)</span> unions several regions of the same dimensionality.</li><li><span style="font-weight: bold;font-family:courier new;" >createMeasuresRegion(Cube)</span> creates a region containing all of the measures of a given cube.</li></ul>The second overloading of <span style="font-weight: bold;font-family:courier new;" >createMemberRegion()</span> is interesting because it allows a range of members to be flushed. Probably the most common use case for cache flush -- flushing all cells since a given point in time -- is expressed as a member range. For example, to flush all cells since February 15th, 2006, you would use the following code:<br /><blockquote><span style="font-weight: bold;font-family:courier new;" ><pre>// Lookup members<br />Cube salesCube =<br />connection.getSchema().lookupCube(<br />"Sales", true);<br />SchemaReader schemaReader =<br />salesCube.getSchemaReader(null);<br />Member memberTimeOct15 =<br />schemaReader.getMemberByUniqueName(<br />new String[]{"Time", "2006", "Q1"", "2" ,"15},<br />true);<br /><br />// Create a cache region defined by<br />// [Time].[1997].[Q1].[2].[15] to +infinity.<br />CacheControl.CellRegion measuresRegion =<br />cacheControl.createMeasuresRegion(<br />salesCube);<br />CacheControl.CellRegion regionTimeFeb15 =<br />cacheControl.createMemberRegion(<br />true, memberTimeFeb15, false, null, true);</pre></span></blockquote>Recall that the cell cache is organized in terms of columns, not members. This makes member ranges difficult for mondrian to implement. A range such as "February 15th 2007 onwards" becomes<br /><blockquote><span style="font-weight: bold;font-family:courier new;" ><pre>year > 2007<br />|| (year = 2007<br />&&amp;amp;amp;amp;amp; (quarter > 'Q1'<br />   || (quarter = 'Q1'<br />       &&amp; (month > 2<br />          || (month = 2<br />              &&amp; day >= 15)))))<br /></pre></span></blockquote><span style="font-weight: bold;font-size:130%;" >Merging and truncating segments</span><br /><br />The current implementation does not actually remove the cells from memory. For instance, in segment YNS#1 in the example above, the cell (1997, USA, OR) is still in the segment, even though it will never be accessed. It doesn't seem worth the effort to rebuild the segment to save a little memory, but we may revisit this decision.<br /><p>In future, one possible strategy would be to remove a segment if more than a given percentage of its cells are unreachable.<br /></p><p>It might also be useful to be able to merge segments which have the same dimensionality, to reduce fragmentation if the cache is flushed repeatedly over slightly different bounds. There are some limitations on when this can be done, since predicates can only constrain one column: it would not be possible to merge the segments {(State=TX, Quarter=Q2)} and {(State=WA, Quarter=Q3)} into a single segment, for example. An alternative solution to fragmentation would be to simply remove all segments of a particular dimensionality if fragmentation is detected.<br /><br /><span style="font-weight: bold;font-size:130%;" >Flushing the dimension cache</span><br /><br />An application might also want to make modifications to a dimension table. Mondrian does not currently allow an application to control the cache of members, but we intend to do so in the future. Here are some notes which will allow this to be implemented.<br /></p><p>The main way that Mondrian caches dimensions in memory is via a cache of member children. That is to say, for a given member, the cache holds the list of all children of that member.<br /></p><p>If a dimension table row was inserted or deleted, or if its key attributes are updated, its parent's child list would need to be modified, and perhaps other ancestors too. For example, if a customer Zachary William is added in city Oakland, the children list of Oakland will need to be flushed. If Zachary is the first customer in Oakland, California's children list will need to be flushed to accommodate the new member Oakland.<br /></p><p>There are a few other ways that members can be cached:<br /></p><ul><li>Each hierarchy has a list of root members, an 'all' member (which may or not be visible), and a default member (which may or may not be the 'all' member).</li></ul><ul><li>Formulas defined against a cube may reference members.</li></ul><ul><li>All other references to members are ephemeral: they are built up during the execution of a query, and are discarded when the query has finished executing and its result set is forgotten.</li></ul><br />Possible APIs might be <span style="font-family:courier new;">flushMember(Member, boolean children)</span> or <span style="font-family:courier new;">flushMembers(CellRegion)</span>.<br /><br /><span style="font-weight: bold;font-size:130%;" >Consistency</span><br /><br />Mondrian's cache implementation must solve several challenges in order to prevent inconsistent query results. Suppose, for example, a connection executes the query<br /><blockquote><span style="font-weight: bold;font-family:courier new;" ><pre>SELECT {[Measures].[Unit Sales]} ON COLUMNS,<br />{[Gender].Members} ON ROWS<br />FROM [Sales]</pre></span></blockquote>It would be unacceptable if, due to updates to the underlying database, the query yielded a result where the total for [All gender] did not equal the sum of [Female] and [Male], such as<br /><blockquote><span style="font-weight: bold;font-family:courier new;" ><pre>            Unit sales<br />=========== ==========<br />All gender     100,000<br />Female          60,000<br />Male            55,000<br /></pre></span></blockquote>We cannot guarantee that the query result is absolutely up to date, but the query must represent the state of the database at some point in time. To do this, the implementation must ensure that both cache flush and cache population are atomic operations.<br /><p>First, Mondrian's implementation must provide <span style="font-weight: bold; font-style: italic;">atomic cache flush</span> so that from the perspective of any clients of the cache. Suppose that while the above query is being executed, another connection issues a cache flush request. Since the flush request and query are simultaneous, it is acceptable for the query to return the state of the database before the flush request or after, but not a mixture of the two.<br /></p><p>The query needs to use two aggregates: one containing total sales, and another containing sales sliced by gender. To see a consistent view of the two aggregates, the implementation must ensure that from the perspective of the query, both aggregates are flushed simultaneously. The query evaluator will therefore either see both aggregates, or see none.<br /></p><p>Second, Mondrian must provide <span style="font-weight: bold; font-style: italic;">atomic cache population</span>, so that the database is read consistently. Consider an example.</p><ol><li>The end user runs a query asking for the total sales:<blockquote><span style="font-weight: bold;font-family:courier new;" ><pre>            Unit sales<br />=========== ==========<br />All gender     100,000<br /></pre></span></blockquote>After that query has completed, the cache contains the total sales but not the sales for each gender.</li><li>New sales are added to the fact table.</li><li>The end user runs a query which shows total sales and sales for male and female customers. The query uses the cached value for total sales, but issues a query to the fact table to find the totals for male and female, and sees different data than when the cache was last populated. As result, the query is inconsistent:<blockquote><span style="font-weight: bold;font-family:courier new;" ><pre>            Unit sales<br />========== ===========<br />All gender     100,000<br />Female          60,000<br />Male            55,000<br /></pre></span></blockquote> </li></ol><p>Atomic cache population is difficult to ensure if the database is being modified without Mondrian's knowledge. One solution, not currently implemented, would be for Mondrian to leverage the DBMS' support for read-consistent views of the data. Read-consistent views are expensive for the DBMS to implement (for example, in Oracle they yield the infamous 'Snapshot too old' error), so we would not want Mondrian to use these by default, on a database which is known not to be changing.<br /></p><p>Another solution might be to extend the Cache Control API so that the application can say 'this part of the database is currently undergoing modification'.</p><p>This scenario has not even considered aggregate tables. We have assumed that aggregate tables do not exist, or if they do, they are updated in sync with the fact table. How to deal with aggregate tables which are maintained asynchronously is still an open question.</p><p> <span style="font-weight: bold;">Metadata cache control</span><br /><br />The <span style="font-family:courier new;">CacheControl</span> API tidies up a raft of (mostly equivalent) methods which had grown up for controlling metadata (schema XML files loaded into memory). The methods<br /></p><ul><li><span style="font-weight: bold;font-family:courier new;" >mondrian.rolap.RolapSchema.clearCache()</span></li><li><span style="font-weight: bold;font-family:courier new;" >mondrian.olap.MondrianServer.flushSchemaCache()</span></li><li><span style="font-weight: bold;font-family:courier new;" >mondrian.rolap.cache.CachePool.flush()</span></li><li><span style="font-weight: bold;font-family:courier new;" >mondrian.rolap.RolapSchema.flushRolapStarCaches(boolean)</span></li><li><span style="font-weight: bold;font-family:courier new;" >mondrian.rolap.RolapSchema.flushAllRolapStarCachedAggregations()</span></li><li><span style="font-weight: bold;font-family:courier new;" >mondrian.rolap.RolapSchema.flushSchema(String,String,String,String)</span></li><li><span style="font-weight: bold;font-family:courier new;" >mondrian.rolap.RolapSchema.flushSchema(DataSource,String)</span></li></ul>are all deprecated and are superseded by the CacheControl methods<br /><blockquote><span style="font-weight: bold;font-family:courier new;" ><pre>void flushSchemaCache();<br /><br />void flushSchema(<br />String catalogUrl,<br />String connectionKey,<br />String jdbcUser,<br />String dataSourceStr);<br /><br />void flushSchema(<br />String catalogUrl,<br />DataSource dataSource);<br /></pre></span></blockquote><br /><span style="font-weight: bold;font-size:130%;" >Conclusion</span><br /><br />The new CacheControl API will be available in mondrian-2.3, which is in the final stages before its release. (The first release candidate will be released in about a week from now, 20th February 2007. The source code is in the perforce repository, for those brave enough to download and build from source.)<br /><br />Give it a try, and let us know how it works with your application.